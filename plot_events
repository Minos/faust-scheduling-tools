#!/usr/bin/env python

import argparse
import csv
import os
import re

import matplotlib.pyplot as plt
import numpy as np

import common as co
from run_strategies import run_strategies


class Run:
    def __init__(self, strategy: str, compiler: str, arch: str):
        self.strategy = strategy
        self.compiler = compiler
        self.arch = arch
        self.loops = 0
        self.events = {}

    def characteristics(self) -> str:
        return f"ss{self.strategy}_{self.compiler}_{self.arch}"


class Program:
    name: str
    runs: [Run]

    def __init__(self, name):
        self.name = name
        self.runs = []


def parse_run_by_path(csv_path, program_name, strategy, compiler, arch) -> Run:
    run = Run(strategy, compiler, arch)
    with open(csv_path, "r") as file:
        reader = csv.reader(file, delimiter=";")
        header = [col for col in next(reader) if len(col) > 0]
        events = [[] for h in header if len(h) > 0]
        loops = 0
        for row in reader:
            for i, col in enumerate(row):
                if len(col) > 0:
                    events[i].append(int(col))
            loops += 1
        run.events = {k: np.array(events[i]) for i, k in enumerate(header)}
        run.loops = loops
    return run


def parse_run(directory, program_name, strategy, compiler, arch, run_number) -> Run:
    csv_path = (
        f"{directory}/{program_name}.bench/"
        f"{program_name}_ss{strategy}_{compiler}_{arch}.r{run_number}.csv"
    )
    return parse_run_by_path(csv_path, program_name, strategy, compiler, arch)


def plot_run(run, ax):
    x = np.arange(0, run.loops)
    lw = 0.5

    instr = run.events[co.instructions] / co.scaling_factor
    st_m = run.events[co.stalls_mem]
    st_t = run.events[co.stalls_total]

    ax.fill_between(
        x,
        instr + st_m,
        instr + st_t,
        lw=lw,
        color="xkcd:light purple",
        label="stalls(other)",
    )
    ax.fill_between(
        x, instr, instr + st_m, lw=lw, color="xkcd:purple", label="stalls(mem)"
    )
    ax.fill_between(x, 0, instr, lw=lw, color="xkcd:burnt orange", label="instr/4")

    ax.plot(x, run.events[co.cycles], lw=lw, label="cycles", color="black")

    ax.set_ylim(ymin=0)
    ax.set_xlim(xmin=0, xmax=len(x))


def plot_single_run(path, output_file):
    directory, filename = os.path.split(path)
    pattern = r"(.*)_ss(.)_(.*)_(.*).r([0-9]+).csv"
    match = re.fullmatch(pattern, filename)
    if not match:
        print(f"File name {filename} does not match {pattern}.")
        exit(1)

    program_name = match.group(1)
    strategy = match.group(2)
    compiler = match.group(3)
    arch = match.group(4)

    run = parse_run_by_path(path, program_name, strategy, compiler, arch)

    fig, ax = plt.subplots(1)
    plot_run(run, ax)
    ax.legend()
    ax.set_title(
        f"{program_name} ({co.COMPILER_LABELS[compiler]} "
        f"{co.arch_LABELS[arch]}) : {co.STRATEGY_LABELS[strategy]}"
    )

    if output_file:
        plt.savefig(output_file, bbox_inches="tight")
    else:
        plt.show()


def plot_multiple_runs(
    path, compilers, archs, run_number, output_file, *, override=False
):
    directory, filename = os.path.split(path)
    program_name, _ = os.path.splitext(filename)

    run_strategies(
        directory, program_name, compilers, archs, run_number, override=override
    )

    runs = [
        parse_run(directory, program_name, s, cc, a, run_number)
        for cc in compilers
        for a in archs
        for s in co.STRATEGIES
    ]

    ymax = max([np.max(run.events[co.cycles]) for run in runs]) * 1.1

    ncols = len(compilers) * len(archs)
    if ncols == 1:
        figsize = (6, 6)
    elif ncols == 2:
        figsize = (8, 6)
    else:
        figsize = (12, 6)

    fig, axes = plt.subplots(
        len(co.STRATEGIES),
        ncols,
        figsize=figsize,
        sharey=True,
        sharex=True,
        squeeze=False,
    )

    for run, ax in zip(runs, (axes if len(runs) == 16 else axes.T).flatten()):
        plot_run(run, ax)
        ax.set_title(f"{co.STRATEGY_LABELS[run.strategy]}")
        ax.set_title(
            f"{co.COMPILER_LABELS[run.compiler]} {co.ARCH_LABELS[run.arch]}, "
            f"{co.STRATEGY_LABELS_SHORT[run.strategy]}"
        )
        ax.set_ylim(ymax=ymax)

    handles, labels = axes[0, 0].get_legend_handles_labels()
    fig.legend(handles, labels, ncols=4, loc="lower center")
    fig.suptitle(program_name)

    plt.subplots_adjust(hspace=0.5)

    if output_file:
        plt.savefig(output_file, bbox_inches="tight")
    else:
        plt.show()


def main():
    parser = argparse.ArgumentParser(
        prog="Plot detailed events",
        description="Plot raw perf events generated by run_strategies",
    )

    parser.add_argument("path", help="DSP program or directory")
    parser.add_argument("-r", "--run", help="Run number", default=0)
    parser.add_argument(
        "-c",
        "--compiler",
        help=f"Restrict to given compiler ({', '.join(co.COMPILERS)})",
        default=None,
    )
    parser.add_argument(
        "-a",
        "--arch",
        help=f"Restrict to given arch ({', '.join(co.ARCHS)})",
        default=None,
    )
    parser.add_argument(
        "--clang-native", help="Restrict to clang-native", action="store_true"
    )
    parser.add_argument(
        "-f", "--force", help="Override previous runs", action="store_true"
    )
    parser.add_argument("-o", "--output", help="Output plot to file", default=None)

    args = parser.parse_args()
    path, ext = os.path.splitext(args.path)

    if args.clang_native:
        compilers = [co.clang]
        archs = [co.native]
    else:
        compilers = [args.compiler] if args.compiler is not None else co.COMPILERS
        archs = [args.arch] if args.arch is not None else co.ARCHS

    plt.style.use("./report.mplstyle")
    # When outputing to png format, we need a higher DPI.
    if args.output:
        plt.rcParams["figure.dpi"] = 512

    if ext == ".csv":
        plot_single_run(args.path, args.output)
    elif ext == ".dsp" or ext == ".bench":
        plot_multiple_runs(
            args.path, compilers, archs, args.run, args.output, override=args.force
        )


if __name__ == "__main__":
    main()
