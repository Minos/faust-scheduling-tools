#!/usr/bin/env python

import argparse
import csv
import hashlib
import io
import os
import subprocess

import numpy as np

import common as co
import build


class RunException(BaseException):
    def __init__(self, cmd, process):
        self.cmd = cmd
        self.process = process

    def __str__(self):
        return (
            f"Execution failed with return code "
            f"{self.process.returncode}:\n"
            f"{' '.join(self.cmd)}\n"
            f"{self.process.stderr.decode('utf-8')}"
        )


class RunResult:
    def __init__(self, run, loops, events, times):
        self.run = run
        self.loops = loops
        self.events = events
        self.times = times


class Run:
    def __init__(self, directory, program_name, compiler, arch, strategy):
        self.directory = directory
        self.program_name = program_name
        self.compiler = compiler
        self.arch = arch
        self.strategy = strategy
        self.path = build.bench_binary(directory, program_name, strategy, compiler, arch)

    def print_run_info(self):
        print(f"  RUN    {self.program_name} "
              f"[strategy {self.strategy}, {self.compiler}, {self.arch}]")

    def output(self, events, nloops):
        measures = f"events: {sorted(events)}, nloops: {nloops}"
        run_hash = hashlib.sha1(measures.encode('utf-8')).hexdigest()[:8]
        return f"{self.path}.{run_hash}.csv"

    def exec(self, *, events=[], nloops=1000, override=False):
        output = None
        if not override:
            output = self.output(events, nloops)
            if (os.path.exists(output)
                    and os.path.getmtime(output) > os.path.getmtime(self.path)):
                with open(output) as f:
                    return parse_run_output(self, f)

        self.print_run_info()

        cmd = [self.path,
               '-r',
               '-n', str(nloops),
               '-e', ','.join(events)]

        proc = subprocess.run(cmd, capture_output=True, text=True)

        if proc.returncode != 0:
            raise RunException(cmd, proc)

        if output is not None:
            with open(output, 'w') as f:
                print(proc.stdout, file=f)

        return parse_run_output(self, io.StringIO(proc.stdout))


def parse_run_output(run, output) -> RunResult:
    reader = csv.reader(output, delimiter=";")
    header = [col for col in next(reader) if len(col) > 0]
    events = [[] for h in header if len(h) > 0]
    loops = 0
    for row in reader:
        if len(row) > 0:
            for i, col in enumerate(row):
                if len(col) > 0:
                    events[i].append(int(col))
            loops += 1

    events_dict = {k: np.array(events[i]) for i, k in enumerate(header)}
    times = events_dict.pop(co.time, None)

    return RunResult(run, loops, events_dict, times)


def run_strategies(
    directory,
    program_name,
    *,
    compilers=co.compilers,
    archs=co.archs,
    events=[],
    nloops=1000,
    override=False
):
    build.build_benchmarks(f"{directory}/{program_name}.dsp",
                           compilers=compilers, archs=archs)

    runs = [
        Run(directory, program_name, cc, a, s)
        for cc in compilers
        for a in archs
        for s in co.strategies
    ]

    return [r.exec(events=events, nloops=nloops, override=override)
            for r in runs]


def main():
    parser = argparse.ArgumentParser(
        prog="Plot detailed events",
        description="Plot raw perf events generated by run_strategies",
    )

    parser.add_argument("path", help="DSP program or directory")
    parser.add_argument("-r", "--run", help="Run number", default=0)
    parser.add_argument(
        "-c",
        "--compiler",
        help=f"Restrict to given compiler ({', '.join(co.compilers)})",
        default=None,
    )
    parser.add_argument(
        "-a",
        "--arch",
        help=f"Restrict to given arch ({', '.join(co.archs)})",
        default=None,
    )
    parser.add_argument(
        "-e", action="append", default=[],
        help="A comma-separated list of linux perf events to measure"
    )
    parser.add_argument(
        "-n", default=1000,
        help="Number of loops to run"
    )

    args = parser.parse_args()

    compilers = [args.compiler] if args.compiler is not None else co.compilers
    archs = [args.arch] if args.arch is not None else co.archs

    files = sorted(co.find_dsp(args.path), key=str.lower)

    if len(files) == 0:
        parser.print_help()
        exit(1)

    events = sum([arg.split(",") for arg in args.e], [])
    nloops = args.n

    for file in files:
        directory, filename = os.path.split(file)
        program_name, ext = os.path.splitext(filename)
        run_strategies(directory, program_name, compilers, archs, args.run,
                       events, nloops, override=False)


if __name__ == "__main__":
    main()
